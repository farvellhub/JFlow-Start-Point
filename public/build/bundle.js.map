{"version":3,"sources":["webpack://jflow-start/./node_modules/@farvell/jflow-core/index.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/Lightbox/lightbox.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/Lightbox/lightboxConstructor.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/Lightbox/lightboxHandler.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/eventHandler.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/parallaxText.js","webpack://jflow-start/./node_modules/@farvell/jflow-core/src/style.js","webpack://jflow-start/./src/styles/index.scss?2775","webpack://jflow-start/webpack/bootstrap","webpack://jflow-start/webpack/runtime/make namespace object","webpack://jflow-start/./src/main.js"],"names":["require","Handler","initPage","Promise","resolve","loader","element","css","onTimeout","window","addEventListener","then","console","log"],"mappings":";;;;;;;;;AAAA,gBAAgB,mBAAO,EAAE,kFAAoB;AAC7C,eAAe,mBAAO,EAAE,4FAAyB;AACjD,eAAe,mBAAO,EAAE,kFAAoB;AAC5C,SAAS,mBAAO,EAAE,oEAAa;;AAE/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA,wBAAwB,mBAAO,EAAE,6FAAmB;AACpD,uBAAuB,mBAAO,EAAE,qGAAuB;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,sBAAsB,sCAAsC;AAC5D,yBAAyB,iDAAiD;;AAE1E;AACA,kCAAkC,8BAA8B;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;;AAEA,SAAS,OAAO,4CAA4C;;AAE5D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wD;AACA;AACA;AACA;AACA,C;;;;;;;;;;AClJA,cAAc,mBAAO,EAAE,iEAAU;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,GAAG;AACH;AACA,C;;;;;;;;;;ACtEA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,sCAAsC,iCAAiC;;AAEvE;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;;AAE1C;AACA;AACA,oDAAoD,SAAS;;AAE7D;AACA;AACA,kC;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,C;;;;;;;;;;ACrHA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,iCAAiC;;AAEvE;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,oDAAoD,SAAS;;AAE7D;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,C;;;;;;;;;;AC9GA;AACA;;AAEA;AACA,8B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,WAAW;AAC5D,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA,C;;;;;;;;;;;;AC3BA;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;ACNA;AACA,eAAoBA,mBAAO,CAAE,wEAAF,CAA3B;AAAA,IAAQC,OAAR,YAAQA,OAAR,C,CACA;;;CAIA;;AACA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,GAAM;AACnB,SAAO,IAAIC,OAAJ,CAAY,UAAEC,OAAF,EAAe;AAC9B,QAAMC,MAAM,GAAG,IAAIJ,OAAJ,CAAY;AACvBK,aAAO,EAAE,QADc;AAEvBC,SAAG,EAAE;AAFkB,KAAZ,CAAf;AAKAH,WAAO,CAAEC,MAAM,CAACG,SAAP,CAAkB,IAAlB,CAAF,CAAP;AACH,GAPM,CAAP;AAQH,CATD,C,CAWA;;;AACAC,MAAM,CAACC,gBAAP,CAAwB,MAAxB,EAAgC,YAAM;AAClCR,UAAQ,GACHS,IADL,CACU;AAAA,WAAMC,OAAO,CAACC,GAAR,CAAa,YAAb,CAAN;AAAA,GADV;AAEH,CAHD,E","file":"bundle.js","sourcesContent":["const Handler = require( \"./src/eventHandler\" ),\r\n    Lightbox = require( \"./src/Lightbox/lightbox\" ),\r\n    Parallax = require( \"./src/parallaxText\" ),\r\n\tStyle = require( \"./src/style\" );\r\n\r\nmodule.exports = {\r\n    Handler,\r\n\tStyle,\r\n    Lightbox,\r\n    Parallax\r\n};\r\n","const LightboxHandler = require( \"./lightboxHandler\" ),\r\n\tLightboxConstructor = require( \"./lightboxConstructor\" );\r\n\r\n// Lightbox logic and constructor\r\nmodule.exports = class Lightbox {\r\n\r\n    // fetching data classes to control lightbox\r\n    constructor( config ) {\r\n        // Set param config\r\n\t\tthis.config = new LightboxConstructor( config );\r\n\r\n        // Initializing handler\r\n        this.handler = new LightboxHandler({\r\n            element: \"lightbox\",\r\n            css: data[\"css\"]\r\n        });\r\n\r\n        // Init roullette of images\r\n        this._initRoullette();\r\n\r\n        // Return listen lightbox\r\n        return Object.freeze(Object.create({\r\n\r\n            listen: this.listen.bind( this )\r\n            \r\n        }));\r\n    }\r\n\r\n    // initializing roullette from fetched images\r\n    _initRoullette() {\r\n        this.config.images.forEach(( e, i ) => {\r\n            const image = e.cloneNode(),\r\n                text = this.config.texts[ i ];\r\n\r\n            // Reset image element to lightbox css classes\r\n            image.classList.remove( ...image.classList );\r\n            image.classList.add( \"roullette-image\", this.control );\r\n\r\n            // Pushing images to roullete\r\n            this.config.roullette.img.appendChild( image );\r\n            this.config.roullette.txt.push( text.textContent );\r\n        });\r\n\r\n        // Finally sets the lightbox size to length of roullette\r\n        this.lightboxSize = this.config.roullette.txt.length;\r\n    }\r\n\r\n    // SETTERS\r\n    _setPhoto( src ) { this.config.lightbox.photo.src = src; }\r\n    _setCaption( text ) { this.config.lightbox.caption.textContent = text; }\r\n\r\n    // Update position ( certain positions are conditioned buttons )\r\n    _setLastPosition( position ) { this.lastPosition = position; }\r\n\r\n    _updateFromAll( position ) {\r\n        const photo = this.config.roullette.img.children,\r\n            caption = this.config.roullette.txt;\r\n\r\n        this._setPhoto( photo[ position ].src );\r\n        this._setCaption( caption[ position ] );\r\n    }\r\n\r\n    // Update from previous button\r\n    _updateFromPrevious() {\r\n        const position = this.lastPosition > 0\r\n            ? --this.lastPosition \r\n            : this.lightboxSize;\r\n\r\n        this._updateFromAll( position );\r\n        \r\n        return position;\r\n    }\r\n\r\n    // Update from next button\r\n    _updateFromNext() {\r\n        const position = this.lastPosition < this.lightboxSize\r\n            ? ++this.lastPosition \r\n            : 0;\r\n\r\n        this._updateFromAll( position );\r\n\r\n        return position;\r\n    }\r\n\r\n    // Update from roullete image\r\n    _updateFromRoullette( index ) {\r\n        const length = this.config.conditions.length,\r\n            position = index - length;\r\n\r\n        this._updateFromAll( position );\r\n\r\n        return position;\r\n    }\r\n\r\n    // Update from grid of images\r\n    _updateFromImages( index ) {\r\n        const length = this.config.conditions.length,\r\n            position = ( index - this.lightboxSize)  - length;\r\n\r\n        this._updateFromAll( position );\r\n\r\n        return position;\r\n    }\r\n\r\n    // If conditions return True\r\n    _validUpdate ( classList, name ) {\r\n        const conditions = this.config.conditions;\r\n\r\n        return classList.contains( conditions[ name ]);\r\n    }\r\n\r\n    // Route depending on position\r\n    _updateFrom( classList, index ) {\r\n        let position;\r\n\r\n        if ( this._validUpdate( classList, \"roullette\" ) ) {\r\n            position = this._updateFromRoullette(index);\r\n\r\n        } else if ( this._validUpdate( classList, \"previous\" ) ) {\r\n            position = this._updateFromPrevious();\r\n\r\n        } else if ( this._validUpdate( classList, \"next\" ) ) {\r\n            position = this._updateFromNext();\r\n\r\n        } else { position = this._updateFromImages( index ); }\r\n\r\n        this._setLastPosition( position );\r\n    }\r\n\r\n    // Update state from all conditions\r\n    _update() {\r\n        \r\n        const lastClick = this.handler.lastClicked(),\r\n            classList = lastClick.element.classList;\r\n            \r\n        if ( classList.contains( this.config.exit ) ) return;\r\n\r\n        this._updateFrom( classList, lastClick.index );\r\n    }\r\n\r\n    // Listener handler\r\n    async listen() {\r\n        this.handler.setAfterFunc( this._update, this ); \r\n        return this.handler.onClick( this.config.control, this.conditions )\r\n\t\t\t.then( console.log( \"Lightbox is working!\" ) );\r\n    }\r\n}","const Style = require( \"../style\" );\r\n\r\n// Lightbox DOM constructor\r\nmodule.exports = class LightboxConstructor {\r\n\tconstructor( config ) {\r\n\t\tthis._createLightbox();\r\n\t\tthis._styleLightbox( config.color );\r\n\t\t\r\n\t\treturn this._setLightboxConfig( config )\r\n\t}\r\n\t\r\n    // Setting lightbox properties\r\n\t_setLightboxConfig( config ) {\r\n\t\treturn {\r\n\t\t\timages: document.querySelectorAll( config[\"images\"] ),\r\n\t\t\ttexts: document.querySelectorAll( config[\"texts\"] ),\r\n\t\t\tlightbox: {\r\n\t\t\t\tphoto: document.getElementById( \"lighbox-photo\" ),\r\n\t\t\t\tcaption: document.getElementById( \"lightbox-caption\" ),\r\n\t\t\t},\r\n\t\t\troullette: {\r\n\t\t\t\timg: document.getElementById( \"lightbox-roullette\" ),\r\n\t\t\t\ttxt: []\r\n\t\t\t},\r\n\t\t\tcontrol: \"lightbox-control\",\r\n        \texit: \"lightbox-close\",\r\n        \tconditions: {\r\n           \t\troullette: \"roullette-image\",\r\n            \tprevious: \"previous-button\", \r\n            \tnext: \"next-button\",\r\n            \tlength: 2\r\n\t\t\t}\r\n        };\r\n\t}\r\n\r\n\t// Putting lightbox html to DOM\r\n\t_createLightbox() {\r\n\t\tconst body = document.getElementsByTagName( \"body\" );\r\n\r\n\t\tbody.innerHTML += `\r\n\t\t\t<section id=\"lightbox\" class=\"fixed-wrapper lightbox-wrapper\">\r\n\t\t\t\t<span class=\"button fixed-button lightbox-close lightbox-control\">x</span>\r\n\r\n\t\t\t\t<section class=\"wrapper lightbox\">\r\n\t\t\t\t\t<figure class=\"wrapper lightbox-photo-wrapper\">\r\n\t\t\t\t\t\t<article class=\"lightbox-previous\">\r\n\t\t\t\t\t\t\t<span class=\"button lightbox-button vertical-align previous-button lightbox-control\"><</span>\r\n\t\t\t\t\t\t</article>\r\n\t\t\t\t\t\t<img id=\"lightbox-photo\" class=\"lightbox-photo all-align\" src=\"#\" alt=\"lightbox-main-photo\">\r\n\t\t\t\t\t\t<article class=\"lightbox-next\">\r\n\t\t\t\t\t\t\t<span class=\"button lightbox-button vertical-align next-button lightbox-control\"><</span>\r\n\t\t\t\t\t\t</article>\r\n\t\t\t\t\t</figure>\r\n\t\t\t\t</section>\r\n\r\n\t\t\t\t<p id=\"lightbox-caption\" class=\"horizontal-align lightbox-caption\"></p>\r\n\t\t\t\t<nav id=\"lightbox-roullette\" class=\"horizontal-align roullette\"></nav>\r\n\t\t\t</section>\r\n\t\t`;\r\n\r\n\t\tbody.style.position = \"relative\";\r\n\t}\r\n\r\n\t_styleLightbox( color = \"rgba( 12,12,12, 0.9)\" ) {\r\n\t\tnew Style({\r\n\r\n\t\t\tbackgroundColor: color\r\n\r\n\t\t}).setStyles( \"lightbox-wrapper\" );\r\n\t}\r\n}","// Lightbox event handler \r\nmodule.exports = class LightboxHandler {\r\n\r\n    // ... Animation { element: idName, css: className || [className] }\r\n    constructor( ...animations ) {\r\n\r\n        // Init array of animations.\r\n        this.animations = [];\r\n        this._initAnimations( animations );\r\n\r\n        // Return function to Lightbox logic\r\n        return Object.freeze(Object.create({\r\n\r\n            setAfterFunc: this.setAfterFunc.bind( this ),\r\n            lastClicked: this.lastClicked.bind( this ),\r\n            onClick: this.onClick.bind( this )\r\n\r\n        }));\r\n    }\r\n\r\n    // Setting animations object and css array\r\n    _initAnimations( animations ) {\r\n        animations.forEach(( a ) => {\r\n            this.animations.push({\r\n                element: document.getElementById( a.element ),\r\n                css: Array.isArray( a.css ) ? a.css : [ a.css ]\r\n            });\r\n        });\r\n        \r\n        this._setDefaultAnimation();\r\n        \r\n    }\r\n\r\n    // If css provided is an array\r\n    _setDefaultAnimation() {\r\n        if ( this.animations.length > 1 ) {\r\n            const animation = this.animations[0],\r\n                element = animation.element,\r\n                css = animation.css\r\n\r\n            this._animateByCss( element, css[0] );\r\n        }\r\n    }\r\n\r\n    // Needs for logic in Lightbox, controls roullette updates\r\n    setAfterFunc( func, that, ...args ) {\r\n        this._afterFunc = () => {\r\n            if ( typeof func == \"function\"\r\n                && typeof that == \"object\" )\r\n                return that[ func.name ]( args );\r\n        };\r\n\r\n        return this;\r\n    }\r\n\r\n    // Only update animation if its condition returns true\r\n    _isConditioned( conditions ) {\r\n        if ( conditions === null ) return false;\r\n            \r\n        const classList = this.lastClick.element.classList;\r\n        let isConditioned = false;\r\n\r\n        Object.keys( conditions ).forEach(( c ) => {\r\n            if ( classList.contains( conditions[ c ] ) ) \r\n                isConditioned = true;\r\n        });\r\n\r\n        return isConditioned;\r\n    }\r\n\r\n    // Toggle class list item\r\n    _toggleAnimation( element, css ) { element.classList.toggle( css ); }\r\n\r\n    // For each animation, animate\r\n    _animate() {\r\n        this.animations.forEach(( a ) => {\r\n            a.css.forEach(( c ) => {\r\n                this._toggleAnimation( a.element, c );\r\n            });        \r\n        });\r\n    }\r\n\r\n    // Controls if have conditions\r\n    _trigger( conditions ) {\r\n        if ( this._isConditioned( conditions ) ) return;\r\n\r\n        this._animate();\r\n    }\r\n\r\n    // Execute all functions atached to the event\r\n    _execution( conditions = null ) {\r\n        this._trigger( conditions );\r\n        \r\n        if ( typeof this._afterFunc === \"function\" )\r\n            this._afterFunc();\r\n    }\r\n\r\n    // Needs in Lightbox class, return last clicked element\r\n    lastClicked() { return this.lastClick; }\r\n\r\n    // Each click updates lastClick variable \r\n    async onClick( controls, conditions ) {\r\n        const keys = document.querySelectorAll( `.${controls}` );\r\n\r\n        keys.forEach(( e, i ) => {\r\n            e.addEventListener(\"click\", () => {\r\n                this.lastClick = { \r\n                    \"element\": e,\r\n                    \"index\": (i - 1) \r\n                };\r\n\r\n                this._execution( conditions );\r\n            });\r\n        });\r\n\r\n        return this;\r\n    }\r\n}","// Generic handler\r\nmodule.exports = class Handler {\r\n\r\n    // Animation { element: idName, css: className || [className] }\r\n    constructor( ...animations ) {\r\n        \r\n        this.animations = [];\r\n        this._initAnimations( animations );\r\n\r\n        // Return event methods\r\n        return Object.freeze(Object.create({\r\n\r\n            onTimeout: this.onTimeout.bind( this ),\r\n            onClick: this.onClick.bind( this ),\r\n            onScroll: this.onScroll.bind( this )\r\n\r\n        }));\r\n    }\r\n\r\n    // Setting animations object and css array\r\n    _initAnimations( animations ) {\r\n        animations.forEach(( a, i ) => {\r\n            this.animations.push({\r\n                element: document.getElementById( a.element ),\r\n                css: Array.isArray( a.css ) ? a.css : [ a.css ]\r\n            });\r\n\r\n            this._setDefaultAnimation( i );\r\n        });\r\n    }\r\n\r\n    // If css provided is not an array\r\n    _setDefaultAnimation( index ) {\r\n        const animation = this.animations[ index ],\r\n            element = animation.element,\r\n            css = animation.css;\r\n\r\n        if ( css.length > 1 )\r\n            this._toggleAnimation( element, css[0] );\r\n    }\r\n\r\n    // Toggle class list item\r\n    _toggleAnimation( element, css ) { element.classList.toggle( css ); }\r\n\r\n    // For each animation, animate\r\n    _animate() {\r\n        this.animations.forEach(( animation ) => {\r\n            animation.css.forEach(( cssName ) => {\r\n                this._toggleAnimation( animation.element, cssName );\r\n            });        \r\n        });\r\n    }\r\n\r\n    // Timeout event, animate given time\r\n    async onTimeout( time ) {\r\n        const timer = setTimeout(( e ) => {\r\n            this._animate();\r\n        }, time);\r\n\t\t\r\n        return this;\r\n    }\r\n\r\n    // Click event triggers animation\r\n    async onClick( controls ) {\r\n        const keys = document.querySelectorAll( `.${controls}` );\r\n\r\n        keys.forEach(() => {\r\n            e.addEventListener(\"click\", ( e ) => {\r\n\t\t\t\te.stopPropagation();\r\n                this._animate();\r\n            });\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n\t// If Offset is inside conditions, animate\r\n\t_triggerScroll( scroll, offset, scrolled ) {\r\n\t\tif (( scroll <= offset && scrolled ) || \r\n            ( scroll >= offset && !scrolled )) {\r\n                \r\n            this._animate();\r\n\t\t\treturn !scrolled;\r\n        }\r\n\r\n\t\treturn scrolled;\r\n\t}\r\n\r\n    // Controls scroll when loads document\r\n    _initScroll( offset ) {\r\n        if ( window.scrollY >= offset ) {\r\n            this._animate();\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Scroll event triggers animation\r\n    async onScroll( offset ) {\r\n        let scrolled = this._initScroll( offset );\r\n\r\n        document.addEventListener(\"scroll\", ( e ) => {\r\n            const scroll = window.scrollY;\r\n\t\t\tscrolled = this.triggerScroll( scroll, offset, scrolled );\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n}","/* Parallax movement */\r\nmodule.exports = class Parallax {\r\n\r\n    // ... HTMLElement, dir 1 = up | -1 = down, minOffset in pixels to active scroll\r\n    constructor( ...config ) {       \r\n        \r\n        // Init multiple configs\r\n        this.config = [];\r\n        this._initConfig( config );\r\n        // Need updates movement at restart\r\n        // Prevents charging scroll at re-render position\r\n        this._updateMovement();\r\n\r\n        // Return listen to move scroll\r\n        return Object.freeze(Object.create({\r\n\r\n            listen: this.listen.bind( this )\r\n\r\n        }));\r\n    }\r\n\r\n    _initConfig( config ) {\r\n        config.forEach(( parallax ) => {\r\n            this.config.push({\r\n                target: document.getElementById( parallax.target ),\r\n                direction: parallax.direction,\r\n                offset: ( parallax.offset ? value.offset : 0 )\r\n            });\r\n        });\r\n    }\r\n\r\n    // Updates movement relative on direction and offset\r\n    _updateMovement( offset = window.scrollY ) {\r\n        // For each parallax configuration object\r\n        this.config.forEach(( value ) => {\r\n            const style = value.target.style,\r\n                movement = ( offset - value.offset ) * value.direction;\r\n\r\n            // Only executes if offset arrives to minOffset\r\n            if ( offset >= value.offset )\r\n                style.transform = `translateY( ${ movement }px)`;\r\n        });\r\n    }\r\n\r\n    _render( offset ) {\r\n        window.requestAnimationFrame(() => {\r\n            this._updateMovement( offset );\r\n        })\r\n    }\r\n\r\n    // Event handler for scroll\r\n    async listen() {\r\n        window.addEventListener(\"scroll\", () => {\r\n            const offset = window.scrollY;\r\n            this._render( offset );\r\n        });\r\n    }\r\n    \r\n}\r\n","// Converts style objetcs into html props.\r\nmodule.exports = class Style {\r\n\tconstructor( styles ) {\r\n\t\t// Object containig style keys\r\n\t\tthis.styles = styles;\r\n\r\n\t\t// Return set styles\r\n\t\treturn Object.freeze(Object.create({\r\n\r\n\t\t\tsetStyles: this.setStyles.bind( this )\r\n\r\n\t\t}));\r\n\r\n\t}\r\n\r\n\t// Set styles to targets clasName\r\n\tsetStyles( className ) {\r\n\t\tthis.elements = [ ...document.getElementsByClassName( className ) ];\r\n\r\n\t\tthis.elements.forEach(( element ) => {\r\n\t\t\tObject.keys( this.styles ).forEach(( key ) => {\r\n\t\t\t\telement.style.key = this.styles.key;\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn this.elements;\r\n\t}\r\n}","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Import modules\r\nconst { Handler } = require( \"@farvell/jflow-core\" );\r\n// Webpack styles\r\nimport \"./styles/index.scss\";\r\n\r\n\r\n// Init Web\r\nconst initPage = () => {\r\n    return new Promise(( resolve ) => {\r\n        const loader = new Handler({\r\n            element: \"loader\",\r\n            css: \"disappear\"\r\n        });\r\n\r\n        resolve( loader.onTimeout( 1600 ) );\r\n    });\r\n};\r\n\r\n// Main function\r\nwindow.addEventListener(\"load\", () => {\r\n    initPage()\r\n        .then(() => console.log( \"Say hello!\" ));\r\n});"],"sourceRoot":""}